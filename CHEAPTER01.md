# fork와 exec: 프로세스의 분신과 변신

리눅스 시스템에서 프로세스 생성과 관리의 핵심 메커니즘인 fork와 exec에 대해 알아봅시다.

## fork: 프로세스의 분신

fork는 현재 실행 중인 프로세스의 복사본을 생성하는 시스템 콜입니다.

### 특징:
- 부모 프로세스의 거의 완벽한 복사본을 생성
- 새로운 프로세스 ID (PID) 할당
- 부모 프로세스의 메모리 및 리소스를 복사 (Copy-on-Write 기법 사용)

### 예시 코드 (C 언어):
```c
pid_t pid = fork();
if (pid == 0) {
    printf("자식 프로세스\n");
} else if (pid > 0) {
    printf("부모 프로세스\n");
} else {
    perror("fork 실패");
}
```

## exec: 프로세스의 변신

exec는 현재 프로세스를 새로운 프로그램으로 대체하는 시스템 콜입니다.

### 특징:
- 현재 프로세스의 메모리 공간을 새 프로그램으로 덮어씀
- 프로세스 ID는 변경되지 않음
- 새 프로그램의 실행을 시작

### 예시 코드 (C 언어):
```c
execl("/bin/ls", "ls", "-l", NULL);
perror("execl 실패"); // exec가 성공하면 이 줄은 실행되지 않음
```

## fork와 exec의 조합

fork와 exec를 함께 사용하면 새로운 프로세스에서 다른 프로그램을 실행할 수 있습니다.

### 일반적인 패턴:
1. fork()로 새 프로세스 생성
2. 자식 프로세스에서 exec()를 호출하여 새 프로그램 실행
3. 부모 프로세스는 필요에 따라 자식 프로세스를 관리

### 예시 코드:
```c
pid_t pid = fork();
if (pid == 0) {
    // 자식 프로세스
    execl("/bin/ls", "ls", "-l", NULL);
    perror("execl 실패");
    exit(1);
} else if (pid > 0) {
    // 부모 프로세스
    wait(NULL); // 자식 프로세스 종료 대기
    printf("자식 프로세스 종료\n");
} else {
    perror("fork 실패");
}
```

## 정리

- fork: 프로세스의 "분신" 생성
- exec: 프로세스의 "변신"
- fork + exec: 새로운 프로세스에서 다른 프로그램 실행

이 메커니즘은 리눅스 시스템의 프로세스 생성과 관리의 기반이 되며, 셸 명령어 실행, 데몬 프로세스 생성 등 다양한 시스템 작업에 활용됩니다.